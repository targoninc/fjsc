{
  "version": 3,
  "sources": ["..\\src\\store.ts", "..\\src\\signals.ts"],
  "sourcesContent": [
    "export class FjsStore {\r\n    static keyName = \"__fjs_store__\";\r\n\r\n    static get(key: string) {\r\n        // @ts-ignore\r\n        return window[this.keyName][key];\r\n    }\r\n\r\n    static set(key: any, value: any) {\r\n        // @ts-ignore\r\n        window[this.keyName][key] = value;\r\n    }\r\n\r\n    static clear() {\r\n        // @ts-ignore\r\n        window[this.keyName] = {};\r\n    }\r\n\r\n    static remove(key: any) {\r\n        // @ts-ignore\r\n        delete window[this.keyName][key];\r\n    }\r\n\r\n    static getAll() {\r\n        // @ts-ignore\r\n        return window[this.keyName];\r\n    }\r\n\r\n    static keys() {\r\n        // @ts-ignore\r\n        return Object.keys(window[this.keyName]);\r\n    }\r\n\r\n    static values() {\r\n        // @ts-ignore\r\n        return Object.values(window[this.keyName]);\r\n    }\r\n\r\n    static getSignalValue(key: any) {\r\n        return this.get(key).value;\r\n    }\r\n\r\n    static setSignalValue(key: any, value: any) {\r\n        this.get(key).value = value;\r\n    }\r\n}\r\n\r\n/**\r\n * If called with one argument, gets the value for that key, otherwise saves it to the store.\r\n * @param key\r\n * @param value\r\n * @returns {*|void}\r\n */\r\nexport function store(key = null, value = null): any | void {\r\n    if (!window) {\r\n        console.warn(\"store() is not supported outside of the browser!\");\r\n        return;\r\n    }\r\n    // @ts-ignore\r\n    if (!window[FjsStore.keyName]) {\r\n        // @ts-ignore\r\n        window[FjsStore.keyName] = {};\r\n    }\r\n    if (arguments.length === 1) {\r\n        return FjsStore.get(arguments[0]);\r\n    } else if (arguments.length === 2) {\r\n        return FjsStore.set(arguments[0], arguments[1]);\r\n    }\r\n\r\n    throw new Error(\"Passing more than 2 arguments to store() is not supported.\");\r\n}",
    "import {store} from \"./store.ts\";\r\n\r\nexport interface BoolValueAssignments<T> {\r\n    [key: string]: {\r\n        onTrue: T,\r\n        onFalse: T,\r\n    }\r\n}\r\n\r\nexport type SignalCallback<T> = (newValue: T, changed: boolean) => void;\r\n\r\nexport class Signal<T> {\r\n    _callbacks: SignalCallback<T>[] = [];\r\n    _value: T;\r\n    _values: { [key: string]: Signal<T> } = {};\r\n\r\n    constructor(initialValue: T, updateCallback: SignalCallback<T> = () => {\r\n    }, key = null) {\r\n        this._value = initialValue;\r\n        this._values = {};\r\n        this._callbacks.push(updateCallback);\r\n        if (key) {\r\n            store().set(key, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates an object with boolean signals that update when {this} updates.\r\n     * @param assignments {Object} e.g. { someKey: { onTrue: value1, onFalse: value2 } }\r\n     */\r\n    boolValues(assignments: BoolValueAssignments<T> = {}) {\r\n        for (let key in assignments) {\r\n            this._values[key] = signal<T>(this._value ? assignments[key].onTrue : assignments[key].onFalse);\r\n        }\r\n        this.subscribe((newValue: T) => {\r\n            for (let key in assignments) {\r\n                this._values[key].value = newValue ? assignments[key].onTrue : assignments[key].onFalse;\r\n            }\r\n        });\r\n        return this._values;\r\n    }\r\n\r\n    unsubscribeAll() {\r\n        this._callbacks = [];\r\n    }\r\n\r\n    subscribe(callback: SignalCallback<T>) {\r\n        this._callbacks.push(callback);\r\n    }\r\n\r\n    unsubscribe(callback: SignalCallback<T>) {\r\n        const index = this._callbacks.indexOf(callback);\r\n        if (index >= 0) {\r\n            this._callbacks.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    get onUpdate(): SignalCallback<T>[] {\r\n        return this._callbacks;\r\n    }\r\n\r\n    set onUpdate(callback: SignalCallback<T>) {\r\n        this._callbacks.push(callback);\r\n    }\r\n\r\n    get value(): T {\r\n        return this._value;\r\n    }\r\n\r\n    set value(value: T) {\r\n        const changed = this._value !== value;\r\n        this._value = value;\r\n        this._callbacks.forEach(callback => callback(value, changed));\r\n    }\r\n}\r\n\r\nexport function signal<T>(initialValue: T) {\r\n    return new Signal<T>(initialValue);\r\n}\r\n\r\nexport function compute<T, Args extends any[]>(\r\n    valueFunction: (...args: Args) => T,\r\n    ...signals: {[K in keyof Args]: Signal<Args[K]>}\r\n): Signal<T> {\r\n    const getValues = () => signals.map(s => s.value) as Args;\r\n    let out = signal<T>(valueFunction(...getValues()));\r\n\r\n    for (const sig of signals) {\r\n        sig.subscribe((_, changed) => {\r\n            if (!changed) {\r\n                return;\r\n            }\r\n            out.value = valueFunction(...getValues());\r\n        });\r\n    }\r\n    return out;\r\n}\r\n\r\nexport async function asyncCompute<T, Args extends any[]>(\r\n    valueFunction: (...args: Args) => Promise<T>,\r\n    ...signals: { [K in keyof Args]: Signal<Args[K]> }\r\n): Promise<Signal<T>> {\r\n    const getValues = () => signals.map(s => s.value) as Args;\r\n    let out = signal<T>(await valueFunction(...getValues()));\r\n\r\n    for (const sig of signals) {\r\n        sig.subscribe(async (_, changed) => {\r\n            if (!changed) {\r\n                return;\r\n            }\r\n            out.value = await valueFunction(...getValues());\r\n        });\r\n    }\r\n    return out;\r\n}\r\n\r\n/**\r\n * Short wrapper to make dependent signals easier.\r\n * @deprecated Use compute() instead\r\n * @param sourceSignal {Signal} Whenever the source signal is updated, the updateMethod gets called to update the output signal.\r\n * @param updateMethod {Function} Should return the value to update the output signal with.\r\n */\r\nexport function computedSignal<T>(sourceSignal: Signal<any>, updateMethod: Function): Signal<T> {\r\n    const returnSignal = signal<T>(updateMethod(sourceSignal.value));\r\n    sourceSignal.subscribe((newVal: (T)) => {\r\n        try {\r\n            returnSignal.value = updateMethod(newVal);\r\n        } catch (e) {\r\n            // @ts-ignore\r\n            returnSignal.value = null;\r\n        }\r\n    });\r\n    return returnSignal;\r\n}\r\n\r\n/**\r\n * @deprecated Use compute() instead\r\n * @param sourceSignal\r\n * @param propertyName\r\n */\r\nexport function signalFromProperty(sourceSignal: Signal<any>, propertyName: string) {\r\n    return compute((source: any) => {\r\n        if (!source) {\r\n            return null;\r\n        }\r\n        return source[propertyName];\r\n    }, sourceSignal);\r\n}"
  ],
  "mappings": ";AAAO,MAAM,SAAS;AAAA,SACX,UAAU;AAAA,SAEV,GAAG,CAAC,KAAa;AAEpB,WAAO,OAAO,KAAK,SAAS;AAAA;AAAA,SAGzB,GAAG,CAAC,KAAU,OAAY;AAE7B,WAAO,KAAK,SAAS,OAAO;AAAA;AAAA,SAGzB,KAAK,GAAG;AAEX,WAAO,KAAK,WAAW,CAAC;AAAA;AAAA,SAGrB,MAAM,CAAC,KAAU;AAEpB,WAAO,OAAO,KAAK,SAAS;AAAA;AAAA,SAGzB,MAAM,GAAG;AAEZ,WAAO,OAAO,KAAK;AAAA;AAAA,SAGhB,IAAI,GAAG;AAEV,WAAO,OAAO,KAAK,OAAO,KAAK,QAAQ;AAAA;AAAA,SAGpC,MAAM,GAAG;AAEZ,WAAO,OAAO,OAAO,OAAO,KAAK,QAAQ;AAAA;AAAA,SAGtC,cAAc,CAAC,KAAU;AAC5B,WAAO,KAAK,IAAI,GAAG,EAAE;AAAA;AAAA,SAGlB,cAAc,CAAC,KAAU,OAAY;AACxC,SAAK,IAAI,GAAG,EAAE,QAAQ;AAAA;AAE9B;AAQO,SAAS,KAAK,CAAC,MAAM,MAAM,QAAQ,MAAkB;AACxD,OAAK,QAAQ;AACT,YAAQ,KAAK,kDAAkD;AAC/D;AAAA,EACJ;AAEA,OAAK,OAAO,SAAS,UAAU;AAE3B,WAAO,SAAS,WAAW,CAAC;AAAA,EAChC;AACA,MAAI,UAAU,WAAW,GAAG;AACxB,WAAO,SAAS,IAAI,UAAU,EAAE;AAAA,EACpC,WAAW,UAAU,WAAW,GAAG;AAC/B,WAAO,SAAS,IAAI,UAAU,IAAI,UAAU,EAAE;AAAA,EAClD;AAEA,QAAM,IAAI,MAAM,4DAA4D;AAAA;;;AC1DzE,MAAM,OAAU;AAAA,EACnB,aAAkC,CAAC;AAAA,EACnC;AAAA,EACA,UAAwC,CAAC;AAAA,EAEzC,WAAW,CAAC,cAAiB,iBAAoC,MAAM;AAAA,KACpE,MAAM,MAAM;AACX,SAAK,SAAS;AACd,SAAK,UAAU,CAAC;AAChB,SAAK,WAAW,KAAK,cAAc;AACnC,QAAI,KAAK;AACL,YAAM,EAAE,IAAI,KAAK,IAAI;AAAA,IACzB;AAAA;AAAA,EAOJ,UAAU,CAAC,cAAuC,CAAC,GAAG;AAClD,aAAS,OAAO,aAAa;AACzB,WAAK,QAAQ,OAAO,OAAU,KAAK,SAAS,YAAY,KAAK,SAAS,YAAY,KAAK,OAAO;AAAA,IAClG;AACA,SAAK,UAAU,CAAC,aAAgB;AAC5B,eAAS,OAAO,aAAa;AACzB,aAAK,QAAQ,KAAK,QAAQ,WAAW,YAAY,KAAK,SAAS,YAAY,KAAK;AAAA,MACpF;AAAA,KACH;AACD,WAAO,KAAK;AAAA;AAAA,EAGhB,cAAc,GAAG;AACb,SAAK,aAAa,CAAC;AAAA;AAAA,EAGvB,SAAS,CAAC,UAA6B;AACnC,SAAK,WAAW,KAAK,QAAQ;AAAA;AAAA,EAGjC,WAAW,CAAC,UAA6B;AACrC,UAAM,QAAQ,KAAK,WAAW,QAAQ,QAAQ;AAC9C,QAAI,SAAS,GAAG;AACZ,WAAK,WAAW,OAAO,OAAO,CAAC;AAAA,IACnC;AAAA;AAAA,MAGA,QAAQ,GAAwB;AAChC,WAAO,KAAK;AAAA;AAAA,MAGZ,QAAQ,CAAC,UAA6B;AACtC,SAAK,WAAW,KAAK,QAAQ;AAAA;AAAA,MAG7B,KAAK,GAAM;AACX,WAAO,KAAK;AAAA;AAAA,MAGZ,KAAK,CAAC,OAAU;AAChB,UAAM,UAAU,KAAK,WAAW;AAChC,SAAK,SAAS;AACd,SAAK,WAAW,QAAQ,cAAY,SAAS,OAAO,OAAO,CAAC;AAAA;AAEpE;AAEO,SAAS,MAAS,CAAC,cAAiB;AACvC,SAAO,IAAI,OAAU,YAAY;AAAA;AAG9B,SAAS,OAA8B,CAC1C,kBACG,SACM;AACT,QAAM,YAAY,MAAM,QAAQ,IAAI,OAAK,EAAE,KAAK;AAChD,MAAI,MAAM,OAAU,cAAc,GAAG,UAAU,CAAC,CAAC;AAEjD,aAAW,OAAO,SAAS;AACvB,QAAI,UAAU,CAAC,GAAG,YAAY;AAC1B,WAAK,SAAS;AACV;AAAA,MACJ;AACA,UAAI,QAAQ,cAAc,GAAG,UAAU,CAAC;AAAA,KAC3C;AAAA,EACL;AACA,SAAO;AAAA;AAGX,eAAsB,YAAmC,CACrD,kBACG,SACe;AAClB,QAAM,YAAY,MAAM,QAAQ,IAAI,OAAK,EAAE,KAAK;AAChD,MAAI,MAAM,OAAU,MAAM,cAAc,GAAG,UAAU,CAAC,CAAC;AAEvD,aAAW,OAAO,SAAS;AACvB,QAAI,UAAU,OAAO,GAAG,YAAY;AAChC,WAAK,SAAS;AACV;AAAA,MACJ;AACA,UAAI,QAAQ,MAAM,cAAc,GAAG,UAAU,CAAC;AAAA,KACjD;AAAA,EACL;AACA,SAAO;AAAA;AASJ,SAAS,cAAiB,CAAC,cAA2B,cAAmC;AAC5F,QAAM,eAAe,OAAU,aAAa,aAAa,KAAK,CAAC;AAC/D,eAAa,UAAU,CAAC,WAAgB;AACpC,QAAI;AACA,mBAAa,QAAQ,aAAa,MAAM;AAAA,aACnC,GAAP;AAEE,mBAAa,QAAQ;AAAA;AAAA,GAE5B;AACD,SAAO;AAAA;AAQJ,SAAS,kBAAkB,CAAC,cAA2B,cAAsB;AAChF,SAAO,QAAQ,CAAC,WAAgB;AAC5B,SAAK,QAAQ;AACT,aAAO;AAAA,IACX;AACA,WAAO,OAAO;AAAA,KACf,YAAY;AAAA;",
  "debugId": "E3AF199ECF4F761F64756E2164756E21",
  "names": []
}